## 스택
- 한쪽 끝에서만 자료를 넣고 뺄 수 있는 자료구조
- 마지막으로 넣은 것이 가장 먼저 나오기 때문에 Last In First Out (LIFO)라고도 한다.
- push: 스택의 가장 위에 자료를 넣는 연산
- pop: 스택의 가장 위의 자료를 빼는 연산
- top: 스택의 가장 위의 자료를 보는 연산
- empty: 스택이 비어있는지 아닌지를 알아보는 연산
- size: 스택에 저장되어 있는 자료의 개수를 알아보는 연산
- 스택의 구현 
	- 배열을 이용하여 구현
    	- push의 구현
        	- stack의 size번째의 배열에 값을 넣고 size를 1 증가시키면 된다.
        - pop의 구현
        	- stack의 size-1번째를 지워버리고 size를 -1하는 것
- 스택의 예제
	- boj.kr/9012
    	- 올바른 괄호 문자열인지 알아보는 문제 
        - 괄호문자열이란? 
        	- (와 )로만 이루어진 문자열
        - 올바른 괄호 문자열: 괄호의 쌍이 올바른 문자열
        - 닫는 괄호의 위치는 어디에 위치해야 할까?
        	- 왼쪽에 있어야 한다.
            - 아직 짝이 맞지 않아야 한다.
			- 가장 오른쪽에 있는 괄호.
        - 가장 빠르게 떠오른 아이디어
        	- 닫는 괄호의 개수와 여는 괄호의 개수를 세어서 맞으면 클리어?
            	- )( 등의 문제를 해결할 수 없다.
            - 스택에 괄호를 순서대로 PUSH하고 괄호가 맞아떨어지면 POP
                - 마지막에 닫는 괄호가 나왔는데 스택이 비어있다면 여는 괄호가 부족
                - 마지막에 여는 괄호가 나왔는데 스택이 비어있다면 닫는 괄호가 부족
                - 마지막에 스택에 아무것도 남지 않는다면 클리어
        - CNT를 이용한 문제 해결 아이디어
        	- 기존 개수 세기 아이디어에서 발전
            - '(' 여는 괄호가 들어온 경우와 ')' 닫는 괄호가 들어온 경우를 구분하여 조건
            ```java
			public class Main{
              String valid(String s) {
               int cnt = 0;
                  
                for(int i=0; i<s.length(); i++{
                  if(s.charAt(i) == '('){
                    cnt += 1;
                  }
                  else{
                    if(cnt == 0){
                      return -1;
                    } else{
                      cnt -= 1; 
                    }
                  }
                }
                return cnt;
              }
                    
              public static void main(String args[]){
                BufferedReader br = new BufferedReader(new InputStreamReader(System.io));
                String str = br.readLine();
                if(valid(str) == 0)
                  System.out.println("success");
                else
                  System.out.println("fail");
              }       
            }
            ```
