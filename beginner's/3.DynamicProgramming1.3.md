## 이친수
- boj.kr/2193
- 이진수에서 특별한 속성이 추가됨
	1. 0으로 시작하지 않는다.
    2. 1이 두번 연속으로 나타나지 않는다.
	- 이를테면 1, 10, 100, 101, 1000, 1001이 이친수
    - 0010101이나 101101은 각각 1,2 번 규칙에 위배되므로 이친수가 아니다.
- 케이스 분할
	- n번째 자리에 0이 온 경우
    - n번째 자리에 1이 온 경우
    - 확실한 것들은 fix시키고 유동적인 것들만 보는 능력이 필요
    	- ex) n=4일때
        	1. 앞의 10은 무조건 고정
            2. 맨 뒤의 숫자는 0 또는 1만 가능하다.
           	3. 가운데 올 수 있는 숫자는?
            	3. 1. 맨 뒤가 0일 때 0과 1 둘 다 가능
                3. 2. 맨 뒤가 1일 때는 0만 가능
        - 케이스 분할을 이용하여 올 수 있는 숫자를 제한하고 쉽게 풀 수 있다.
- 구현
```java
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.math.BigInteger;

    public class Main{

        public static void main(String args[]) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            int n = Integer.parseInt(br.readLine());

            BigInteger[] d = new BigInteger[91];

            d[1] = new BigInteger("1");
            d[2] = new BigInteger("1");
            d[3] = new BigInteger("2");
            d[4] = new BigInteger("3");
            d[5] = new BigInteger("5");

            for(int i=6; i<=n; i++){
                d[i] = (d[i-1].add(d[i-2]));
            }

            System.out.println(d[n]);
        }
    }
```

## 쉬운 계단 수
- 이친 수와 비슷
- 인접한 모든 자리수의 차이가 1이 남
	- ex) 456456
- 길이가 N인 계단 수의 개수는?
- 접근법
	- 이친수와 마찬가지로 끝에 L이 온다고 가정하고 풀면 쉽다.
    - D[N][L]처럼 2차원 배열을 만든다. N은 자리수의 개수고 L은 끝에 오는 숫자이다.
    - D[3][2]는 3자리수일 때, 끝이 2로 끝나는 계단 수의 갯수이다.
- 구현
```java
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;

    public class Main{


        public static void main(String args[]) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            int n = Integer.parseInt(br.readLine());

            long[][] d = new long[101][101];
            int mod = 1000000000;

            for (int i = 1; i <= 9; i++)
                d[1][i] = 1;

            for(int i=2; i<=n; i++) {
                for (int j=0; j<=9; j++) {
                    if(j-1 < 0) d[i][j] = d[i-1][j+1];
                    else d[i][j] = d[i-1][j-1] + d[i-1][j+1];
                    d[i][j] %= mod;
                }
            }

            long sum = 0;
            for (int i = 0; i <= 9; i++)
                sum += d[n][i];

            System.out.println(sum % mod);
        }
    }
```

## 오르막 수
- boj.kr/11057
- 수의 자리가 오름차순을 이루는 수
- 인접한 수가 같아도 오름차순으로 친다.
- 수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 문제
- 수는 0으로 시작할 수 있다.
	- ex) 123345, 357, 88888888, 15559999
- 문제 해결 포인트
	- N=2부터 숫자가 1증가할 때마다 올 수 있는 숫자의 범위를 잘 계산하면 된다.
    - 간단하게 생각했을 때, N=2일 때, D[N][1] = D[N][0] + D[N][1] 인 것을 알면 된다.
    	- 1로 끝나는 2자리 수는 01 11 여기서 1 앞에 붙는 0 1은 이전 배열에서 참조하면 된다.
- 구현
```java
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.math.BigInteger;

    public class Main{


        public static void main(String args[]) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            int n = Integer.parseInt(br.readLine());
            BigInteger[][] d = new BigInteger[1001][1001];


            for(int i=1; i<=2; i++){
                for(int j=0; j<=9; j++){
                    if( i == 1) d[i][j] = new BigInteger("1");
                    if( i == 2) d[i][j] = new BigInteger(Integer.toString(j+1));
                }
            }

            for(int i=3; i<=n; i++){
                for(int j=0; j<=9; j++){
                    d[i][j] = new BigInteger("0");
                    for(int k=0; k<=j; k++){
                        d[i][j] = d[i][j].add(d[i-1][k]);
                    }
                }
            }

            BigInteger sum = new BigInteger("0");
            for(int i=0; i<=9; i++)
                sum = sum.add(d[n][i]);

            System.out.println(sum.mod(new BigInteger("10007")));
        }
    }
```
