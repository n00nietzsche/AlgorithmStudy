## 나머지 연산
- (A+B) % C = ( (A%C) + (B%C) ) % C
- DP문제에서 경우의 수가 너무 큰 경우에 주로 사용한다. 
- BigInteger의 구현보다 n으로 나눈 나머지를 출력하라는 경우가 매우 많다.
- 예시
	- (A+B) % C = ( (A%C) + (B%C) ) % C
	- A = q<sub>1</sub>c+r<sub>1</sub>
    - B = q<sub>2</sub>c+r<sub>2</sub>
    - A+B = (q<sub>1</sub>+q<sub>2</sub>)c + (r<sub>1</sub>+r<sub>2</sub>)
    - A%C = r<sub>1</sub>
    - B%C = r<sub>2</sub>
    - (A%C) + (B%C) = (r<sub>1</sub> + r<sub>2</sub>) % C
- 컴퓨터의 정수는 저장할 수 있는 범위가 저장되어 있기 때문에, 답을 M으로 나눈 나머지를 출력하라는 문제가 등장한다.
- (A+B) mod M = ((A mod M) + (B mod M)) mod M
- (AxB) mod M = ((A mod M) x (B mod M)) mod M
- 나누기의 경우에는 성립하지 않는다. (Modular Inverse를 구해야 함)
- 뺄셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 해야한다.
	- (A-B) mod M = ((A mod M) - (B mod M) + M) mod M

## 나머지
- boj.kr/10430
- 조건
	- 첫째 줄에 (A+B) % C
    - 둘째 줄에 (A%C + B%C) % C
    - 셋째 줄에 (AxB) % C
    - 넷째 줄에 (A%C x B%C) % C
- 그대로 출력하면 정답이 된다.
	- 정답보다는 이 네 연산이 같다는 것을 이해하는 것이 더 중요한 문제

## 최대공약수
- 최대공약수는 줄여서 GCD(Greatest Common Divisor) 라고 쓴다.
- 두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다.
- 최대 공약수를 구하는 가장 쉬운 방법은 2부터 min(A, B)까지 모든 정수로 나누어 보는 방법
```java
	int g = 1;
	for (int i=2; i<=min(a,b); i++) {
      if (a % i == 0 && b % i == 0) {
        g = i;  
      }
    }
```
- 최대 공약수가 1인 두 수를 서로소(Coprime)라고 한다.

	### 유클리드 호제법
	- 최대공약수를 구하는 좀 더 빠른 방법
	- a를 b로 나눈 나머지를 r이라고 했을 때
    - GCD(a, b) = GCD(b, r)과 같다.
    - r이 0이면 그 때 b가 최대 공약수이다.
    - GCD(24, 16) = GCD(16, 8) = GCD(8, 0) = 8
    	- GCD 괄호 내부의 값을 (B, A % B)로 계속하여 치환했을 때, A % B가 0이 되면 GCD
