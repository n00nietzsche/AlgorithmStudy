## Sort
- there are a lot of sort algorithms
- selection, bubble, insertion, quick, heap and merge sort ...
- use sort algorithm which has time complexity of O(NlgN)
- it's better to use sort in STL than making myself
- sort(begin, end)
	- it sorts between begin and right before the end
    - function that sorts begin, end
- it is usually used for sorting before solving problems
- implementation code in C++
```C++
	int n = 10;
	int a[10] = {};
	sort(a, a+n);

	vector<int> a;
	sort(a.begin(), a.end());
```

## Sort Numbers 2
- boj.kr/2751
- sorting the number of N
- sort in Java (using built-in sort algorithm)
	```java
        import java.io.BufferedReader;
        import java.io.IOException;
        import java.io.InputStreamReader;
        import java.util.Arrays;
    
        public class Main {
            public static void main(String[] args) throws IOException {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                int n = Integer.parseInt(br.readLine());
                int[] arr = new int[n];
    
                for(int i=0; i<n; i++){
                    arr[i] = Integer.parseInt(br.readLine());
                }
    
                Arrays.sort(arr);
                StringBuilder sb = new StringBuilder();
    
                for(int i=0; i<n; i++){
                    sb.append(arr[i] + "\n");
                }
    
                System.out.print(sb);
            }
        }	
    ```
    
## Sort Coordinates
- boj.kr/11650
- solution in Java
	```java
		import java.io.BufferedReader;
        import java.io.IOException;
        import java.io.InputStreamReader;
        import java.util.Arrays;
        import java.util.StringTokenizer;
        
        class Point implements Comparable<Point> {
            int x, y;
        
            Point(int x, int y) {
                this.x = x;
                this.y = y;
            }
        
            public String toString() {
                return this.x + " " + this.y;
            }
        
            public int compareTo(Point that) {
                if (this.x < that.x) {
                    return -1;
                } else if (this.x == that.x) {
                    if (this.y < that.y) {
                        return -1;
                    } else if (this.y == that.y) {
                        return 0;
                    } else {
                        return 1;
                    }
                } else {
                    return 1;
                }
            }
        
        
        }
        
        public class Main {
            public static void main(String args[]) throws IOException {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                int n = Integer.parseInt(br.readLine());
                Point points[] = new Point[n];
        
        
                for(int i=0; i<n; i++) {
                    String xy = br.readLine();
                    StringTokenizer st = new StringTokenizer(xy, " ");
                    int x = Integer.parseInt(st.nextToken());
                    int y = Integer.parseInt(st.nextToken());
                    points[i] = new Point(x, y);
                }
        
                Arrays.sort(points);
        
                StringBuilder sb = new StringBuilder();
        
                for( Point p : points ){
                    sb.append(p.toString() + "\n");
                }
        
                System.out.println(sb.toString().trim());
            }
        }
	```
    
## Sort coordinates 2
- boj.kr/11651
- solution is almost the same as above one


## Stable Sorting
- When there are some cards like this
	- 7♠, 5♥, 2♥, 5♠
    ♦ ♣
- When cards are sorted in the order in which numbers are increasing
	- how would be the order of 5♥ and 5♠
    	- it can be like 
        	- 2♥, 5♥, 5♠, 7♠
            	- it retains the order of input
			- 2♥, 5♠, 5♥, 7♠
            	- it doesn't retain the order of input
        - we couldn't expect what would be the first between heart and spade
- An alignment algorithm that retains the order before sorting when there is the same thing is called a Stable Sorting algorithm.

